### 原型/构造函数/实例对象三者关系

构造函数（Student） new Student 得到实例对象

实例对象的\_\_proto 属性指向 Student.prototype 即原型对象

原型对象的 constrctor 属性又指向创建实例对象的构造函数

### 原型链

对象都有一个\_\_props 属性指向创建此对象的构造函数的原型对象

因为原型对象也是对象所以也有\_\_props 属性指向 Object 的原型对象最终值为 null

由于对象就会有\_\_props 属性以此链接形成一个链式结构叫为原型链

构造函数创建的实例对象的\_\_props 指向该构造函数的原型对象

而此原型对象的\_\_props 属性指向 Object 的原型对象最终值为 null

### 继承

常见的几种继承方式：

父构造函数：Father 子构造函数：Son

- 一：原型链继承

把子构造函数的 prototype 指向父构造函数的实例

再把 constrctor 属性指回子构造函数

Son.prototype = new Father

Son.prototype.constrctor = Son

缺点：由于使用相同的原型其中一个的原型发生改变其余的实例也会受影响

- 二：借用构造函数继承

把父构造函数当成普通函数在子构造函数中调用通过 call()方法改变其 this 指向

function Son () {

Father.call(this)

}
缺点：不能继承方法且不能复用

- 三：组合继承

原型链继承和借用构造函数继承相结合

使用原型链继承继承属性和方法借用构造函数继承来继承实例属性

function Son(){

Father.call(this)

}

Son.prototype = new Father;

缺点：调用两次父构造函数生成两次实例以至于性能浪费

- 四：寄生组合继承

与组合继承相似只是把：Son.prototype = new Father

改为：Son.prototype = Object.create(Father.prototype)

解决了原型链继承和构造函数继承的缺点

- 五：使用 es6 中类的继承 extends 关键字，

在子类使用 super 关键字使用父类的构造方法

### 事件传参

@click="fn" 在回调函数直接通过参数可以拿到事件对象

@click="fn($event)" 这个时候​$event 是固定写法

$event 的理解：

在原生 DOM 原生事件中，$event 指的是事件源对象

在组件自定义事件，$event 代表的是子组件抛出的数据

### 自定义指令语法和应用

当内置的指令满足不了我们的需求的时候就可以使用自定义指令

通过 Vue.directive 进行自定义指令

自定义指令的三个钩子函数：

bind：当属性绑定的时候执行，只会有一次

inserted：当前指令所在元素插入到 DOM 的时候执行，只会有一次

update：当前指令所在组件中的 data 数据有更新就会执行，可以执行多次

### 单向数据流

指数据是单向的，如父向子组件传值 poprs 是只读的

，父组件数据发生改变时子组件也会随之改变，而当子组件发生改变时不会影响父组件，

但是当子组件为引用数据类型时只改变属性是可以的

### 双向数据绑定

数据和视图之间的绑定关系（v-model）

数据发生改变时视图随之改变，反之也是如此

### v-model 的作用

可以实现数据的双向绑定

v-model 是一个复合属性是 :value 和@input 事件的语法糖

### v-if 和 v-show 的区别

v-if 和 v-show 实现的功能是一样的 实现了在显示和隐藏之间切换的功能区别有两处：

一：从原理上

v-if ：通过创建和销毁实现功能

v-show ：通过样式的 display:none 来实现功能

二：从使用场景上

v-show：适用于元素显示隐藏频繁切换的时候

v-if：适用于切换不频繁的时候

### v-for 和 v-if 为什么避免一起使用

v-for 的优先级比 v-if 高，当二者同时出现时会有 v-if 的值为 false 而 v-for 还在执行这样会有性能浪费的情况了。

解决方式一：在容器元素<template>上使用 v-if

二：在计算属性中先对数据进行判断筛选

### 生命周期

组件从创建到销毁的周期成为生命周期

有四个阶段，每个阶段有两个钩子函数

- 创建

  beforeCreate 创建前

  created 创建后 => 这时数据准备完毕，通常在这时发送 ajxa 请求

* 挂载

  beforeMount 挂载前

  mounted 挂载后 => 这时视图准备完毕，通常在这时获取 DOM 请求

- 更新

  beforeUpdate 更新前 数据已经是最新的，但是视图还是旧的

  updated 更新后 数据和视图都已经变成最新的

- 销毁
  beforeDestroy 销毁前 => 在这时清除开启的定时器 卸载绑定的 DOM 事件

  destroyed 销毁后

其他的钩子函数：缓存组件 keep-alive 相关的两个钩子

activated 激活

deactivated 失活

加了 keep-alive 8 个钩子初始化只会执行一次后面就不会执行了，销毁钩子永远也不会执行

### 父子组件生命周期的顺序

- 初始化阶段：调用先父后子，挂载完成先子后父

父组件 beforeCreate

父组件 created

父组件 beforeMount

子组件 beforeCreate

子组件 created

子组件 beforeMount

子组件 mounted

父组件 mounted

- 更新阶段：调用先父后子 更新完成先子后父

父组件 beforeUpdate

子组件 beforeUpdate

子组件 updated

父组件 updated

- 销毁阶段：调用先父后子 销毁完成先子后父

父组件 beforeDestroy

子组件 beforeDestroy

子组件 destroyed

父组件 destroyed

总结：永远是调用的时候先父后子 完成的时候先子后父

### 浏览器缓存机制

浏览器会将请求后的数据存为离线资源，当下次需要该数据时，浏览器会根据缓存机制选择使用离线数据还是重新发送请求

作用：减少了不必要数据的传输、降低服务器的压力

加快了客户端访问速度

增强用户体验

- 缓存机制分为强缓存与协商缓存两种

强缓存：不向服务端发送请求，强制使用缓存数据

服务器在响应时返回一个过期时间在过期之前使用强缓存，过期之后通过协商缓存决定使用何种方式获取数据

协商缓存：协商缓存由服务器决定是否使用缓存

1.向服务器发送请求资源并携带标识

2.服务器会进行判断浏览器缓存的资源是否真的失效是否更新

    资源更新返回状态码 200 重新发送请求获取数据并进行缓存，重新进入强缓存

    资源未更新返回状态码 304 还使用本地的离线数据

### 两种设计模式

观察者模式和发布订阅模式：

- 观察者模式：

  特点：1. 一对多 2. 有二个主体 一个是被观察者 Dep 一个是观察者 watcher

  观察者模式定义了对象间的一种一对多的依赖关系，当一个对象(被观察者)的状态发生改变时，所有依赖于它的对象(观察者)都将得到通知，并自动更新

- 发布订阅模式：

  特点：1. 多对多 2. 有三个主体 发布者 调度中心 订阅者

  在发布订阅模式中，发送者不会将消息直接发送给订阅者而是通过调度中心

  调度中心维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者

  这二种模式的区别就在于发布订阅模式多了一个调度中心，从而实现解耦

### 深拷贝与浅拷贝

深拷贝和浅拷贝

如果对象只有一层，就可以用浅拷贝，如果对象有多层，就是对象的属性又是一个对象，就需要用深拷贝

浅拷贝可以使用{...obj}或 Object.assign({},obj)

深拷贝可以用 JSON.parse(JSON.stringify(obj))或者递归

但是 JSON.parse(JSON.stringify(obj))有缺点，当对象有方法的时候，方法会丢失

如果对象身上有方法，需要用递归，如果存在循环引用就会出现堆栈溢出

解决思路：处理好的对象存起来，在处理新的对象的时候，先在存的地方找一找有没有处理好，如果有就直接返回

递归实现深拷贝：

```
  function deepClone(target) {
        //这一行如果不用三元判断 如果是数组会有bug会被拷贝成伪数组对象
        var tempObj = Array.isArray(target) ? [] : {};
        for (var key in target) {
          if (typeof target[key] === "object") {
            tempObj[key] = deepClone(target[key]);
          } else {
            tempObj[key] = target[key];
          }
        }
        return tempObj;
      }
```

### Promise

Promise：是异步编程的一种解决方案

从语法上说：Promise 是一个对象它可以获取异步操作的消息，解决回调地狱问题

从功能上说：可以用来封装一个异步操作，获取其成功/失败的值

特点：对象的状态不受外界影响，一旦状态改变就不会再发送变化

缺点：一旦开始就不能取消

Promise 三种状态：1.pending 执行中 2.resolve 成功 3.rejected 失败

实例方法：.then()成功的结果，.catch()异常信息，.finally()无论成功或失败都会执行

Promise.all 中可以将多个异步请求并行操作

应用场景：1.多个请求结果合并在一起 2.合并请求结果并处理错误 3.验证多个请求结果是否都是满足条件

### 数据响应式

指数据发生改变视图随之改变

原理：利用数据劫持 Object.defineProperty 和观察者模式来实现

vue 内部对 data 中数据进行转换，对所有的属性递归实现数据劫持，为每个数据创建一个 Dep 被观察者

对模板进行编译提取里面所有需要数据的地方变成 watcher(观察者),把 watcher 加入到对应 Dep 的观察者列表

当 data 中数据发生改变时，由于进行了数据劫持，所以 vue 内部可以感知到变化，调用相应的 Dep 从而影响该 Dep 的观察者列表中所有 watcher

最后由观察者更新视图

为什么数组的索引不是响应式的 为什么要用 this.$set 来处理(vue官方基于性能的考虑,所以没有对数组进行转换,但是为我们提供了$set 实现响应变化)

### 垃圾回收

引用计数和标记清除两种方式

引用计数：根据变量被引用的数量，如果引用数为零就会被回收，不过会有变量相互引用的情况出现，就不会被回收 内存泄漏

标记清除：看一个变量能否被从根元素根据引用找到该变量，如果不能就回收

### 事件循环--宏任务与微任务

异步任务分为两种，一种是宏任务 一种是微任务

异步要执行的任务和 js 处于同一个进程 和 js 相关的 属于微任务 例如 Promise nextTick

在一个新的进程 做的事情和 js 无关的 就是宏任务 例如 计时器

事件循环：

当同步代码遇到异步代码，直接将异步代码扔到事件队列中，队列分为两种，一种是宏任务队列，一种是微任务队列。

这两个队列，优先执行微任务，当微任务队列清空后，才会去宏任务队列执行宏任务。

当这个队列中，如果发现了宏任务中还有异步任务，再次将异步任务放到异步队列中，

类似递归，再次重复上面的操作，直到完全清空任务队列。

执行顺序 同步代码 -> 微任务 -> 宏任务 -> 微任务

### substr 和 substring 的区别

都用于提取字符串

substr：两个参数都为索引，用于提取两个索引之间的字符串 取头取尾

substring：两个参数第一个为开始索引，第二个为长度，用于提取从起始索引开始之后长度的字符串 取不取尾

### slice 和 splice 的区别

相同点：都能用于数组截取，不同的是：

slice：不会修改原始数组，返回一个新的数组，用于数组截取，两个参数：start:起始索引。end：截止索引（截取不包含此元素）。

splice：修改原始数组，可用于数组添加，替换，删除，index 开始索引。howmany 删除的元素数量，tem1,.....,itemX 表示新增的数组元素

### watch 和计算属性

计算属性：当数据是由一个或多个变量计算而来时使用，计算属性结果会被缓存，并且不能执行异步操作

watch：对数据进行侦听，数据发生改变时被触发，用于在数据发生改变后执行操作

### js 数据类型和数据类型检测

js 数据类型分为两大类：

基本数据类型：srting number boolean null undefined Symbol(es6 新增表示独一无二的值)

复杂数据类型：Array Object Function 等

数据类型检测：typeof 用于检测基本数据类型，检测复杂数据类型返回值全为 Object，不过检测 null 返回值也是 Object console.log(typeof 1) // "number"

instanceof：用于检测复杂数据类型，根据原型链查找，返回值是布尔值 obj instanceof Object //true

toString：检测所有数据类型，Object.prototype.toString.call()

### new 的过程

创建一个空的对象

设置原型链

将构造函数的 this 指向新对象执行函数代码

如果构造函数中没有人为返回一个对象类型的值，则返回这个新对象 obj。否则直接返回那个对象类型值

### 重绘与回流

回流：当页面的结构布局发生变化会造成回流

重绘：当背景颜色，文字颜色和文字样式等不影响结构的样式发生变化时会造成重绘

回流一定会造成重绘，而重绘不一定会造成回流

### let const var 的区别

var let 声明变量 const 声明常量 const 不能更改如果是引用数据类型不能直接更改地址指向可以更改属性

let const 不存在变量提升，并且存在块级作用域，而且会有暂时性死区

### 路由传值的方法，各自异同

路由传参可以分为两大类：

编程式导航的 router.push：

1.字符串--直接传递路由地址，但是不能传递参数 this.$router.push('home')

2.拼接参数传参--在路由后面以?拼接，this.$router.push('/dizi?data=home')

3.使用 name 来确定匹配的路由通过 params 传递参数--this.$router.push({name:'dizi', params:{data:home}})

接收参数使用：this.$router.params.data

4.使用 path 来匹配路由通过 query 传递参数--this.$router.push({path:'dizi',query{data:home}})

接收参数使用：this.$router.query.data

path 和 params 不能一起使用，需要 path 匹配路由的时候要使用 query 来传参

query 在浏览器地址栏中显示参数，而 params 则不显示

声明式导航：通过 router-link 组件的 to 属性实现，1.直接传参 2.通过对象，使用 path 匹配路由 3.通过路由名称 使用 name

### flex:1

通常用于自适应布局

flex:1 是--flex-grow:1,flex-shrink:1,flex-basis:0%的简写形式

flex-grow 当父盒子比所有的子盒子都要大时用于定义子盒子的放大比例

flex-shrink 当父盒子比所有的子盒子都要小时用于定义子盒子的缩小比例

flex-basis 在分配多余空间放大或缩小之前盒子所占据的大小相当于设置初始值

### 数组转树形结构

可使用递归和遍历数组的写法

思路：先提取出树形结构的根节点，再根据根节点与子节点之间的联系把子节点提取并添加到对应根节点的数组里

### img 标签 alt 和 title 的区别

alt：用于替换文本当图片加载失败时显示

title：提示文本 当鼠标放到图片上时显示

### vuex

vue 的核心：1.数据驱动，也就是数据的双向绑定，让视图的内容随着数据的改变而改变

2.组件化系统，可实现扩展 HTML 元素，封装可用的代码

### data 为什么是一个函数

防止多个组件实例对象之间共用一个 data，产生数据污染

而当 data 是一个函数是，让每个组件实例都有自己的作用域，使每个实例相互独立，不会相互影响。

### 虚拟 dom 和 diff 算法

虚拟 DOM：是对真实 dom 的映射和描述，本质上就是一个普通的 js 对象

为什么使用虚拟 DOM：使用虚拟 dom 的性能会相对高一些，因为真实 dom 身上的方法和属性比较多操作起来性能比较慢

并且每操作一次 dom 就会发生一次重绘与回流，虚拟 dom 只会更新 dom 树需要更新的地方，并且只会在渲染真实 dom 的时候触发一次重绘与回流

虚拟 dom 实现高效更新：

是利用虚拟 dom 树的比较，组件初始化时会创建一次虚拟 dom 树，

而数据更新时会再次生成一个虚拟 dom 树通过对新旧 dom 树的比较，按照广度优先同级进行比较，来实现高效更新

diff 算法：三种情况：一.元素改变.就销毁重建，二.元素没有变，属性或内容变了就修改属性或内容

三.v-for 分两种没有 key 或 key 为 index 时采用就地复用，索引相同就会被认为时相同元素，当顺序被破坏时没有改变的元素也会被更新

有 key：( id ) key 为唯一值时只要 key 值相同就认为是同一元素不会去更新哪怕顺序被打乱

虚拟 dom 的作用：高效更新，跨平台

### 同源策略

限制一个文档或它加载的脚本与另一个源的资源进行交互，用与恶意脚本的防护，减少风险

如果两个 URL 的协议 域名 端口号都相同，就称这两个 URL 同源

ps：同源策略不是禁止脚本的运行，而是禁止读取 HTTP 的响应。也就是跨域的资源访问请求是允许的，但是服务端返回的数据是禁止读取的。

### link 和 import 的区别

link 是 html 提供的标签，而 import 是 css 提供的语法规则

加载页面时，link 标签引入的 css 被同时加载，import 引入的 css 将在页面加载完毕后被加载

兼容性：link 作为 HTML 标签不存在兼容性问题，而 import 是 css2 才有的语法，被 IE5 以上支持

可以通过 JS 操作 DOM，插入 link 标签来改变样式，由于 DOM 是基于文档的，无法使用 import 的方式插入样式

### 数组去重方法

一：for 循环 + findIndex

主要利用 findIndex 的特性，查找元素找不到就返回-1， 接下来就需要判断，如果是-1，说明没找到，就往新数组里面添加元素。

二：sort 排序

首先利用 sort 方法进行排序。进行循环，如果原数组的第 i 项和新数组的 i - 1 项不一致，就 push 进去。

三 ：filter + indexOf

indexOf，可以检测某一个元素在数组中出现的位置，找到返回该元素的下标，没找到返回 -1

四：Set

ES6 中新增了数据类型 Set，Set 的一个最大的特点就是数据不重复。Set 函数可以接受一个数组（或类数组对象）作为参数来初始化，利用该特性也能做到给数组去重。
