### 原型/构造函数/实例对象三者关系

构造函数（Student） new Student 得到实例对象

实例对象的\_\_proto 属性指向 Student.prototype 即原型对象

原型对象的 constrctor 属性又指向创建实例对象的构造函数

### 原型链

对象都有一个\_\_props 属性指向创建此对象的构造函数的原型对象

而原型对象也是对象就会有\_\_props 属性以此形成一个链式结构即为原型链

构造函数创建的实例对象的\_\_props 指向该构造函数的原型对象

而此原型对象的\_\_props 属性指向 Object 的原型对象最终值为 null

### 继承

常见的几种继承方式：

父构造函数：Father 子构造函数：Son

- 一：原型链继承

另子构造函数的 prototype 指向父构造函数的实例

再把 constrctor 属性指回子构造函数

Son.prototype = new Father

Son.prototype.constrctor = Son

缺点：由于使用相同的原型其中一个的原型发生改变其余的实例也会受影响

- 二：借用构造函数继承

把父构造函数当成普通函数在子构造函数中调用通过 call()方法改变其 this 指向

function Son () {

Father.call(this)

}
缺点：不能继承方法且不能复用

- 三：组合继承

原型链继承和借用构造函数继承相结合

使用原型链继承继承属性和方法借用构造函数继承来继承实例属性

function Son(){

Father.call(this)

}

Son.prototype = new Father;

缺点：调用两次父构造函数生成两次实例以至于性能浪费

- 四：寄生组合继承

与组合继承相似只是把：Son.prototype = new Father

改为：Son.prototype = Object.create(Father.prototype)

解决了原型链继承和构造函数继承的缺点

- 五：使用 es6 中类的继承 extends 关键字，

在子类使用 super 关键字使用父类的构造方法

### 事件传参

@click="fn" 在回调函数直接通过参数可以拿到事件对象

@click="fn($event)" 这个时候​$event 是固定写法

$event 的理解：

在原生 DOM 原生事件中，$event 指的是事件源对象

在组件自定义事件，$event 代表的是子组件抛出的数据

### 自定义指令语法和应用

当内置的指令满足不了我们的需求的时候就可以使用自定义指令

通过 Vue.directive 进行自定义指令

自定义指令的三个钩子函数：

bind：当属性绑定的时候执行，只会有一次

inserted：当前指令所在元素插入到 DOM 的时候执行，只会有一次

update：当前指令所在组件中的 data 数据有更新就会执行，可以执行多次

### 单向数据流

指数据是单向的，如父向子组件传值 poprs 是只读的

，父组件数据发生改变时子组件也会随之改变，而当子组件发生改变时不会影响父组件，

但是当子组件为引用数据类型时只改变属性是可以的

### 双向数据绑定

数据和视图之间的绑定关系（v-model）

数据发生改变时视图随之改变，反之也是如此

### v-model 的作用

可以实现数据的双向绑定

v-model 是一个复合属性是 :value 和@input 事件的语法糖

### v-if 和 v-show 的区别

v-if 和 v-show 实现的功能是一样的 实现了在显示和隐藏之间切换的功能区别有两处：

一：从原理上

v-if ：通过创建和销毁实现功能

v-show ：通过样式的 display:none 来实现功能

二：从使用场景上

v-show：适用于元素显示隐藏频繁切换的时候

v-if：适用于切换不频繁的时候

### v-for 和 v-if 为什么避免一起使用

v-for 的优先级比 v-if 高，当二者同时出现时会有 v-if 的值为 false 而 v-for 还在执行这样会有性能浪费的情况了。

解决方式一：在容器元素<template>上使用 v-if

二：在计算属性中先对数据进行判断筛选

### 生命周期

组件从创建到销毁的周期成为生命周期

有四个阶段，每个阶段有两个钩子函数

- 创建

  beforeCreate 创建前

  created 创建后 => 这时数据准备完毕，通常在这时发送 ajxa 请求

* 挂载

  beforeMount 挂载前

  mounted 挂载后 => 这时视图准备完毕，通常在这时获取 DOM 请求

- 更新

  beforeUpdate 更新前 数据已经是最新的，但是视图还是旧的

  updated 更新后 数据和视图都已经变成最新的

- 销毁
  beforeDestroy 销毁前 => 在这时清除开启的定时器 卸载绑定的 DOM 事件

  destroyed 销毁后

其他的钩子函数：缓存组件 keep-alive 相关的两个钩子

activated 激活

deactivated 失活

加了 keep-alive 8 个钩子初始化只会执行一次后面就不会执行了，销毁钩子永远也不会执行

### 父子组件生命周期的顺序

- 初始化阶段：调用先父后子，挂载完成先子后父

父组件 beforeCreate

父组件 created

父组件 beforeMount

子组件 beforeCreate

子组件 created

子组件 beforeMount

子组件 mounted

父组件 mounted

- 更新阶段：调用先父后子 更新完成先子后父

父组件 beforeUpdate

子组件 beforeUpdate

子组件 updated

父组件 updated

- 销毁阶段：调用先父后子 销毁完成先子后父

父组件 beforeDestroy

子组件 beforeDestroy

子组件 destroyed

父组件 destroyed

总结：永远是调用的时候先父后子 完成的时候先子后父

### 浏览器缓存机制

浏览器会将请求后的数据存为离线资源，当下次需要该数据时，浏览器会根据缓存机制选择使用离线数据还是重新发送请求

作用：减少了不必要数据的传输、降低服务器的压力

加快了客户端访问速度

增强用户体验

- 缓存机制分为强缓存与协商缓存两种

强缓存：不向服务端发送请求，强制使用缓存数据

服务器在响应时返回一个过期时间在过期之前使用强缓存，过期之后通过协商缓存决定使用何种方式获取数据

协商缓存：协商缓存由服务器决定是否使用缓存

1.向服务器发送请求资源并携带标识

2.服务器会进行判断浏览器缓存的资源是否真的失效是否更新

    资源更新返回状态码 200 重新发送请求获取数据并进行缓存，重新进入强缓存

    资源未更新返回状态码 304 还使用本地的离线数据

### 两种设计模式

观察者模式和发布订阅模式：

- 观察者模式：

  特点：1. 一对多 2. 有二个主体 一个是被观察者 Dep 一个是观察者 watcher

  观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新

- 发布订阅模式：

  特点：1. 多对多 2. 有三个主体 发布者 调度中心 订阅者

  在发布订阅模式中，发送者不会将消息直接发送给订阅者

  调度中心维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者

  这二种模式的区别就在于发布订阅模式多了一个调度中心，从而实现解耦

### 深拷贝与浅拷贝

深拷贝和浅拷贝

如果对象只有一层，就可以用浅拷贝，如果对象有多层，就是对象的属性又是一个对象，就需要用深拷贝

浅拷贝可以使用{...obj}或 Object.assign({},obj)

深拷贝可以用 JSON.parse(JSON.stringify(obj))或者递归

但是 JSON.parse(JSON.stringify(obj))有缺点，当对象有方法的时候，方法会丢失

如果对象身上有方法，需要用递归，如果存在循环引用就会出现堆栈溢出

解决思路：处理好的对象存起来，在处理新的对象的时候，先在存的地方找一找有没有处理好，如果有就直接返回

递归实现深拷贝：

```
  function deepClone(target) {
        //这一行如果不用三元判断 如果是数组会有bug会被拷贝成伪数组对象
        var tempObj = Array.isArray(target) ? [] : {};
        for (var key in target) {
          if (typeof target[key] === "object") {
            tempObj[key] = deepClone(target[key]);
          } else {
            tempObj[key] = target[key];
          }
        }
        return tempObj;
      }
```

### Promise

Promise：是异步编程的一种解决方案

从语法上说：Promise 是一个对象它可以获取异步操作的消息，解决回调地狱问题

从功能上说：可以用来封装一个异步操作，获取其成功/失败的值

特点：对象的状态不受外界影响，一旦状态改变就不会再发送变化

缺点：一旦开始就不能取消

Promise 三种状态：1.pending 执行中 2.resolve 成功 3.rejected 失败

实例方法：.then()成功的结果，.catch()异常信息，.finally()无论成功或失败都会执行

Promise.all 中可以将多个异步请求并行操作

应用场景：1.多个请求结果合并在一起 2.合并请求结果并处理错误 3.验证多个请求结果是否都是满足条件

### 数据响应式

指数据发生改变视图随之改变

原理：利用数据劫持 Object.defineProperty 和观察者模式来实现

vue 内部对 data 中数据进行转换，对所有的属性递归实现数据劫持，为每个数据创建一个 Dep 被观察者

对模板进行编译提取里面所有需要数据的地方变成 watcher(观察者),把 watcher 加入到对应 Dep 的观察者列表

当 data 中数据发生改变时，由于进行了数据劫持，所以 vue 内部可以感知到变化，调用相应的 Dep 从而影响该 Dep 的观察者列表中所有 watcher

最后由观察者更新视图

为什么数组的索引不是响应式的 为什么要用 this.$set 来处理(vue官方基于性能的考虑,所以没有对数组进行转换,但是为我们提供了$set 实现响应变化)

### 垃圾回收

引用计数和标记清除两种方式

引用计数：根据变量被引用的数量，如果引用数为零就会被回收，不过会有变量相互引用的情况出现，就不会被回收

标记清除：看一个变量能否被从根元素根据引用找到该变量，如果不能就回收

### 事件循环--宏任务与微任务

### substr 和 substring 的区别

### slice 和 splice 的区别

### watch 和计算属性

计算属性：当数据是由一个或多个变量计算而来时使用，计算属性结果会被缓存，并且不能执行异步操作

watch：对数据进行侦听，数据发生改变时被触发，用于在数据发生改变后执行操作

### js 数据类型和数据类型检测

js 数据类型分为两大类：

基本数据类型：srting number boolean null undefined Symbol(es6新增表示独一无二的值)

复杂数据类型：Array Object Function等

数据类型检测：typeof 用于检测基本数据类型，复杂数据类型返回值为Object，不过检测null返回值也是Object console.log(typeof 1) // "number"

instanceof：用于检测复杂数据类型，根据原型链查找，返回值是布尔值 obj instanceof Object //true  

toString：检测所有数据类型，Object.prototype.toString.call()

### new 的过程

创建一个空的对象

设置原型链

将构造函数的 this 指向新对象执行函数代码

如果构造函数中没有人为返回一个对象 类型的值，则返回这个新对象 obj。否则直 接返回那个对象类型值

### 重绘与回流

回流：当页面的结构布局发生变化会造成回流

重绘：当背景颜色，文字颜色和文字样式等不影响结构的样式发生变化时会造成重绘

回流一定会重绘，重绘不一定会回流

### let const var 的区别

var let 声明变量 const 声明常量 const 不能更改如果是引用数据类型不能更改地址指向可以更改属性

let const 不存在变量提升，并且存在块级作用域，而且会有暂时性死区

### 路由传值的方法，各自异同

### flex:1

### 数组转树形结构

### img 标签 alt 和 title 的区别

alt：用于替换信息当图片加载失败时显示

title：提示信息当鼠标放到图片上时显示

### vuex

### data 为什么是一个函数