### 原型/构造函数/实例对象三者关系

构造函数（Student） new Student 得到实例对象

实例对象的\_\_proto 属性指向 Student.prototype 即原型对象

原型对象的 constrctor 属性又指向创建实例对象的构造函数

### 原型链

对象都有一个\_\_props 属性指向创建此对象的构造函数的原型对象

而原型对象也是对象就会有\_\_props 属性以此形成一个链式结构即为原型链

构造函数创建的实例对象的\_\_props 指向该构造函数的原型对象

而此原型对象的\_\_props 属性指向 Object 的原型对象最终值为 null

### 继承

常见的几种继承方式：

父构造函数：Father 子构造函数：Son

- 一：原型链继承

另子构造函数的 prototype 指向父构造函数的实例

再把 constrctor 属性指回子构造函数

Son.prototype = new Father

Son.prototype.constrctor = Son

缺点：由于使用相同的原型其中一个的原型发生改变其余的实例也会受影响

- 二：借用构造函数继承

把父构造函数当成普通函数在子构造函数中调用通过 call()方法改变其 this 指向

function Son () {

Father.call(this)

}
缺点：不能继承方法且不能复用

- 三：组合继承

原型链继承和借用构造函数继承相结合

使用原型链继承继承属性和方法借用构造函数继承来继承实例属性

function Son(){

Father.call(this)

}

Son.prototype = new Father;

缺点：调用两次父构造函数生成两次实例以至于性能浪费

- 四：寄生组合继承

与组合继承相似只是把：Son.prototype = new Father

改为：Son.prototype = Object.create(Father.prototype)

解决了原型链继承和构造函数继承的缺点

- 五：使用 es6 中类的继承 extends 关键字，

在子类使用 super 关键字使用父类的构造方法

### 事件传参

@click="fn" 在回调函数直接通过参数可以拿到事件对象

@click="fn($event)" 这个时候​$event 是固定写法

$event 的理解：

在原生 DOM 原生事件中，$event 指的是事件源对象

在组件自定义事件，$event 代表的是子组件抛出的数据

### 自定义指令语法和应用

当内置的指令满足不了我们的需求的时候就可以使用自定义指令

通过 Vue.directive 进行自定义指令

自定义指令的三个钩子函数：

bind：当属性绑定的时候执行，只会有一次

inserted：当前指令所在元素插入到 DOM 的时候执行，只会有一次

update：当前指令所在组件中的 data 数据有更新就会执行，可以执行多次

### 单向数据流

指数据是单向的，如父向子组件传值 poprs 是只读的

，父组件数据发生改变时子组件也会随之改变，而当子组件发生改变时不会影响父组件，

但是当子组件为引用数据类型时只改变属性是可以的

### 双向数据绑定

数据和视图之间的绑定关系（v-model）

数据发生改变时视图随之改变，反之也是如此

### v-model 的作用

可以实现数据的双向绑定

v-model 是一个复合属性是 :value 和@input 事件的语法糖

### v-if 和 v-show 的区别

v-if 和 v-show 实现的功能是一样的 实现了在显示和隐藏之间切换的功能区别有两处：

一：从原理上

v-if ：通过创建和销毁实现功能

v-show ：通过样式的 display:none 来实现功能

二：从使用场景上

v-show：适用于元素显示隐藏频繁切换的时候

v-if：适用于切换不频繁的时候

### v-for 和 v-if 为什么避免一起使用

v-for 的优先级比 v-if 高，当二者同时出现时会有 v-if 的值为 false 而 v-for 还在执行这样会有性能浪费的情况了。

解决方式一：在容器元素<template>上使用 v-if

二：在计算属性中先对数据进行判断筛选

### 生命周期

组件从创建到销毁的周期成为生命周期

有四个阶段，每个阶段有两个钩子函数

- 创建

  beforeCreate 创建前

  created 创建后 => 这时数据准备完毕，通常在这时发送 ajxa 请求

* 挂载

  beforeMount 挂载前

  mounted 挂载后 => 这时视图准备完毕，通常在这时获取 DOM 请求

- 更新

  beforeUpdate 更新前 数据已经是最新的，但是视图还是旧的

  updated 更新后 数据和视图都已经变成最新的

- 销毁
  beforeDestroy 销毁前 => 在这时清除开启的定时器 卸载绑定的 DOM 事件

  destroyed 销毁后

其他的钩子函数：缓存组件 keep-alive 相关的两个钩子

activated 激活

deactivated 失活

加了 keep-alive 8 个钩子初始化只会执行一次后面就不会执行了，销毁钩子永远也不会执行

### 父子组件生命周期的顺序

- 初始化阶段：调用先父后子，挂载完成先子后父

父组件 beforeCreate

父组件 created

父组件 beforeMount

子组件 beforeCreate

子组件 created

子组件 beforeMount

子组件 mounted

父组件 mounted

- 更新阶段：调用先父后子 更新完成先子后父

父组件 beforeUpdate

子组件 beforeUpdate

子组件 updated

父组件 updated

- 销毁阶段：调用先父后子 销毁完成先子后父

父组件 beforeDestroy

子组件 beforeDestroy

子组件 destroyed

父组件 destroyed

总结：永远是调用的时候先父后子 完成的时候先子后父

### 浏览器缓存机制

浏览器会将请求后的数据存为离线资源，当下次需要该数据时，浏览器会根据缓存机制选择使用离线数据还是重新发送请求

作用：减少了不必要数据的传输、降低服务器的压力

加快了客户端访问速度

增强用户体验

- 缓存机制分为强缓存与协商缓存两种

强缓存：不向服务端发送请求，强制使用缓存数据

服务器在响应时返回一个过期时间在过期之前使用强缓存，过期之后通过协商缓存决定使用何种方式获取数据

协商缓存：协商缓存由服务器决定是否使用缓存

1.向服务器发送请求资源并携带标识

2.服务器会进行判断浏览器缓存的资源是否真的失效是否更新

    资源更新返回状态码 200 重新发送请求获取数据并进行缓存，重新进入强缓存

    资源未更新返回状态码 304 还使用本地的离线数据

### 两种设计模式

观察者模式和发布订阅模式：

- 观察者模式：

  特点：1. 一对多 2. 有二个主体 一个是被观察者 Dep 一个是观察者 watcher

  观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新

- 发布订阅模式：

  特点：1. 多对多 2. 有三个主体 发布者 调度中心 订阅者

  在发布订阅模式中，发送者不会将消息直接发送给订阅者

  调度中心维持着发布者和订阅者之间的联系

  这二种模式的区别就在于发布订阅模式多了一个调度中心，从而实现解耦
